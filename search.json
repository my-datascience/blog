[
  {
    "objectID": "posts/Python/mutability_and_cloning.html",
    "href": "posts/Python/mutability_and_cloning.html",
    "title": "Mutability and Cloning",
    "section": "",
    "text": "Let’s talk about the most important principles of lists and other mutable objects. I also want to mention some common “gotchas”.\nTo be open, this description is based on how I understand the topic. In some aspects it differs from what can be found on the internet. I don’t know why, but I think most descriptions of a variable on the internet are either incomplete or incorrect. This is how I understand that and what helps me understand lists, mutability and cloning.",
    "crumbs": [
      "Home",
      "Python",
      "Mutability and Cloning"
    ]
  },
  {
    "objectID": "posts/Python/mutability_and_cloning.html#variables-vs.-pointers-vs.-objects",
    "href": "posts/Python/mutability_and_cloning.html#variables-vs.-pointers-vs.-objects",
    "title": "Mutability and Cloning",
    "section": "Variables vs. Pointers vs. Objects",
    "text": "Variables vs. Pointers vs. Objects\nThis is foundational to understand the whole mutability and cloning thing. As far as I know, variables (or names), pointers (or references) and objects are three completely different things.\n\nVariables live in a namespace. A namespace is a mapping (we can think of it as a dict) from variables to pointers. So a variable is basically a label of a pointer.\nPointers point to a location in memory. I think of them as memory addreses.\nAn object is the actual thing on the location in memory.\n\nSo, to sum this up, variables map to pointers and pointers map to objects.\nIt is common to think that “variables are just names for objects”. Also, I found on the internet sentences like “variables are names associated with concrete objects” or “variable is essentially a name that is assigned to a value”. No, that’s incorrect. A variable is a name of a pointer. And that pointer points to a location in memory where an object can be found. That object has then a value (along with a type and an identity). But a namespace isn’t the only place we can found pointers.",
    "crumbs": [
      "Home",
      "Python",
      "Mutability and Cloning"
    ]
  },
  {
    "objectID": "posts/Python/mutability_and_cloning.html#lists-only-contain-pointers",
    "href": "posts/Python/mutability_and_cloning.html#lists-only-contain-pointers",
    "title": "Mutability and Cloning",
    "section": "Lists Only Contain Pointers",
    "text": "Lists Only Contain Pointers\nOnce we understand the differences between varaibles, pointers and objects, now comes the key to understand lists: Lists only contain pointers. Not objects. Not variables. Pointers. A list is internally basically an array, where each item in the array is a pointer to a memory location.\nThe pointer, as an element of a list, can be created either implicitely, or explicitely. If we type L = ['a'], this is what I call an implicit creation of a pointer. Internally, two new objects are created at two different memory locations: The string 'a' and a new list. A pointer to the string 'a' is placed as the first element of the new list. And a pointer to the new list is placed in the current namespace and is assigned the label L.\nOr, we can place a pointer as an element of a list explicitely. That would look like this:\nA = 'a'\nL = [A]\nFirst, a new object (the string 'a') is created in memory and its pointer is placed to the current namespace with the label A. Second, a new list is created, its first element is the pointer that is named A and a pointer to this new list is placed to the namespace under the name L.\nI think the situation is very similar for dictionaries and sets, meaining they always only contain pointers, but I’m not 100% sure here.",
    "crumbs": [
      "Home",
      "Python",
      "Mutability and Cloning"
    ]
  },
  {
    "objectID": "posts/Python/mutability_and_cloning.html#mutation",
    "href": "posts/Python/mutability_and_cloning.html#mutation",
    "title": "Mutability and Cloning",
    "section": "Mutation",
    "text": "Mutation\nMutation is the ability of some python objects (types of objects) to change. Numbers, strings, tuples, bools or ranges are examples of immutable types. Once objects of these types are created, they cannot be changed. Any pointers that point to such objects will always point to the very same unchanged objects.\nExamples of mutable types are lists, dictionaries or sets. After they are created, they can be changed (extended, shortened, replaced elements etc.). If multiple pointers point to such an object, a change made through one pointer is visible through all other pointers:\n\nL1 = []\nL2 = [L1, 'abc']\nL1.append(1)\nprint(L2)\n\n[[1], 'abc']\n\n\nIn this example, the list L2 has two pointers to it: One is the variable L1 and the other is the first element of the list L2. Both places, the varaible and the first element of L2, contain the same memory address - the one where L1 is located. A change made using the variable L1 is visible through L2.",
    "crumbs": [
      "Home",
      "Python",
      "Mutability and Cloning"
    ]
  },
  {
    "objectID": "posts/Python/mutability_and_cloning.html#self-referencing",
    "href": "posts/Python/mutability_and_cloning.html#self-referencing",
    "title": "Mutability and Cloning",
    "section": "Self-Referencing",
    "text": "Self-Referencing\nI learned this only after many years of using Python and it blew my mind. Lists contain pointers, ok. But there are no limitations on those pointers. In particular, nothing prevents a list to cointain a pointer to itself:\n\nL1 = ['abc']\nL1.append(L1)\nprint(L1)\n\n['abc', [...]]\n\n\nIn this example, the second element of the list L1 is a pointer that points to memory location where the list L1 is located. The interactive python shell has a particular way of letting you know this once you try to print that list: It prints the string [...] as the second element of the list, where the pointer to itself is. Surprisingly, one can normally iterate over that list:\n\nfor i in L1:\n    print(i)\n\nabc\n['abc', [...]]",
    "crumbs": [
      "Home",
      "Python",
      "Mutability and Cloning"
    ]
  },
  {
    "objectID": "posts/Python/mutability_and_cloning.html#common-gotchas",
    "href": "posts/Python/mutability_and_cloning.html#common-gotchas",
    "title": "Mutability and Cloning",
    "section": "Common Gotchas",
    "text": "Common Gotchas\nThere are two gotchas I want to mention here, both from my favorite textbook “Introduction to Computation and Programming Using Python” (I have to manage the references in some more methodical way than just typing the whole long name each time…), pages 98 and 99.\n\n1) The repetition operator *\n\nL1 = [[]]*2\nL2 = [[], []]\nfor i in range(len(L1)):\n    L1[i].append(i)\n    L2[i].append(i)\nprint(f'{L1 = }, {L2 = }')\n\nL1 = [[0, 1], [0, 1]], L2 = [[0], [1]]\n\n\nHere, the repetition operator creates a sequence where the very same object is repeated n times. In this example, L1 is a list of two pointers that are the same (they both point to the same empty list). Whereas the list L2 is made of two different pointers (each is pointing to a different empty list).\n\n\n2) Default values\n\ndef append_val(val, list_1 = []):\n    list_1.append(val)\n    print(list_1)\n\nappend_val(3)\nappend_val(4)\n\n[3]\n[3, 4]\n\n\nThe objects to be used as default values are created at a function definition time. And a pointer to this one object is bound to list_1 each time the function is called without the second parameter.\nWe can test the “default value is created at a function definition time” claim like this. The string 'here!' is not printed until the function append_val is defined. And that function is not defined until the default value of param2 is created and that value is not created until the function create_default_val finishes creating it.\n\ndef create_default_val():\n    print('Inside create_default_val')\n\ndef append_val(val, list_1 = [], param2 = create_default_val()):\n    list_1.append(val)\n\nprint('here!')\n\nInside create_default_val\nhere!",
    "crumbs": [
      "Home",
      "Python",
      "Mutability and Cloning"
    ]
  },
  {
    "objectID": "posts/Python/mutability_and_cloning.html#cloning",
    "href": "posts/Python/mutability_and_cloning.html#cloning",
    "title": "Mutability and Cloning",
    "section": "Cloning",
    "text": "Cloning\n\nImmutable Types\nAs a preface, I think we only talk about “copying” in connection with mutable types. But here I think it is interesting to look at this behavior of immutable types:\n\nprint('\\'abc\\'')\nprint('  ', id('abc'))\nprint('  ', id('abc'))\nprint('2')\nprint('  ', id(2))\nprint('  ', id(2))\nprint('True')\nprint('  ', id(True))\nprint('  ', id(True))\nprint('None')\nprint('  ', id(None))\nprint('  ', id(None))\nprint('range(10)')\nprint('  ', id(range(10)))\nprint('  ', id(range(10)))\nprint('3.14')\nprint('  ', id(3.14))\nprint('  ', id(3.14))\nprint('  ', id(float(3.14)) == id(float(3.14)))\nprint('(2,)')\nprint('  ', id((2,)))\nprint('  ', id((2,)))\nprint('  ', id((2,)) == id((2,)))\n\n\n'abc'\n   1592388385840\n   1592388385840\n2\n   140703871009736\n   140703871009736\nTrue\n   140703870124464\n   140703870124464\nNone\n   140703870124528\n   140703870124528\nrange(10)\n   1592486025168\n   1592486025168\n3.14\n   1592480060080\n   1592483131696\n   True\n(2,)\n   1592486316928\n   1592485965792\n   True\n\n\nIt is important to mention here that these results are not universal. For example, in an online python compiler I tried, ranges that had the same value vere in fact different objects. Nevertheless, it is worth keeping in mind that:\n\nDifferent instances (with the same value) of some built-in immutable types can be the very same object.\nFor some types, this can be true only for instances created as part of a single expression (e.g. id(3.14) == id(3.14)); for other types both instances can be created even in separate expressions.\n\nThis behavior of Python is called interning and it is of course performed to improve efficiency. There is also a function of the module sys, called sys.intern (see here), that can intern a string on demand.\nBtw this article on GeeksForGeeks says that for integers, interning only happens for values between -5 and 256.\nAnyway, back to cloning. Of mutable types. There are two basic versions of cloning, a shallow copy and a deep copy. Again, the examples here are from my already mentioned favorite textbook, pages 101 and 102.\n\n\nShallow Copy\nRecall that a list is just an array of pointers. A shallow copy is simply a new list (a new object) that contains the same pointers.\nA shallow copy of a list L can be obtained by:\n\nslicing (L[:])\nusing the list method copy (L.copy())\nusing list comprehension ([e for e in L])\nusing the list constructor (list(L))\nor using the generic copy method of the copy module (copy.copy(L)).\n\nRemember, it would be just a copy of the pointers. If objects that those pointers point at are mutable, any changes made to the objects via the old list are visible in the new list.\n\nL = [2]\nL1 = [L]\nL2 = L1[:]\nL.append(3)\nprint(f'{L1 = }, {L2 = }')\n\nL1 = [[2, 3]], L2 = [[2, 3]]\n\n\n\n\nDeep Copy\nIf we have a list whose elements are mutable, we might want to copy the list in such a way that changes via the old list do not propagate to the new list - in other words, we might want not only to copy the list, but also its elements. This is what the function deepcopy of the module copy does:\n\nimport copy\n\n\nL = [2]\nL1 = [L]\nL2 = copy.deepcopy(L1)\nL.append(3)\nprint(f'{L1 = }, {L2 = }')\n\nL1 = [[2, 3]], L2 = [[2]]\n\n\nHere, L2 is not affected by the mutation of L, because L2 doesn’t contain anymore the object to which L points. It contains its copy. I’m not sure about the exact internal mechanics, but I imagine the deepcopy function does this: It goes to L1 and makes a shallow copy of it. It then goes to each element in that new list, copies the object to which the element points (creates new such object at a different memory location) and replaces the pointer in the new list with a pointer to this new object. It does that “all the way to the bottom”, meaning if an element of the list being copied is another list, its deep copy is also created:\n\nL = [2]\nL1 = [[L]]\nL2 = copy.deepcopy(L1)\nL.append(3)\nprint(f'{L1 = }, {L2 = }')\n\nL1 = [[[2, 3]]], L2 = [[[2]]]\n\n\nThere are two subtleties to be mentioned here. First, if the list to be copied is self-referencing, the deepcopy function somehow notices it and replicates the structure in the new list. Second, if two elements of the old list contain the same pointer, the object this pointer points to is copied only once and the new pointer is used twice in the new list. In other words, also this structure is maintained.\n\nL1 = ['abc']\nL1.append(L1)\nprint(L1, id(L1), id(L1[-1]))\nL2 = copy.deepcopy(L1)\nprint(L2, id(L2), id(L2[-1]))\n\n['abc', [...]] 1640674902656 1640674902656\n['abc', [...]] 1640674911232 1640674911232\n\n\n\nL = ['abc']\nL1 = [L, L]\nL2 = copy.deepcopy(L1)\nL2[0].append(2)\nprint(L2)\n\n[['abc', 2], ['abc', 2]]",
    "crumbs": [
      "Home",
      "Python",
      "Mutability and Cloning"
    ]
  },
  {
    "objectID": "posts/Python/floating_point.html",
    "href": "posts/Python/floating_point.html",
    "title": "Floating Point Arithmetics",
    "section": "",
    "text": "This is a topic that breaks my head each time I try to understand it. This is a summary of what I know and what I don’t.",
    "crumbs": [
      "Home",
      "Python",
      "Floating Point Arithmetics"
    ]
  },
  {
    "objectID": "posts/Python/floating_point.html#purpose",
    "href": "posts/Python/floating_point.html#purpose",
    "title": "Floating Point Arithmetics",
    "section": "Purpose",
    "text": "Purpose\nFloating point is a way to represent scientific notation in a computer. Its purpose is to be able to represent both values that are very very small and values that are very very big.",
    "crumbs": [
      "Home",
      "Python",
      "Floating Point Arithmetics"
    ]
  },
  {
    "objectID": "posts/Python/floating_point.html#internal-representation",
    "href": "posts/Python/floating_point.html#internal-representation",
    "title": "Floating Point Arithmetics",
    "section": "Internal representation",
    "text": "Internal representation\nInternal representation is a tripplet of sign, exponent and a significand (also called fraction or mantissa, represents the significant digits). On most current computers, the used standard is called IEEE 754. Its double-precision format, “binary64”, has 1 bit for the sign, 11 bits for the exponent and 53 bits for the significand.",
    "crumbs": [
      "Home",
      "Python",
      "Floating Point Arithmetics"
    ]
  },
  {
    "objectID": "posts/Python/floating_point.html#normalization",
    "href": "posts/Python/floating_point.html#normalization",
    "title": "Floating Point Arithmetics",
    "section": "Normalization",
    "text": "Normalization\nSince there are possibly many ways to decompose a number into such triplet (for example, the number 12 can be represented by either \\(12 \\times 2^0\\), \\(3 \\times 2^2\\) or \\(1.5 \\times 2^3\\)), the numbers are stored in a normalized form. That means that the significand represents digits after a decimal point after a \\(1\\). So each floating point number is represented as \\((-1)^{sign} \\times 1.fraction \\times 2^{exponent}\\). The purpose of this normalization is to maximize efficiency and precision.",
    "crumbs": [
      "Home",
      "Python",
      "Floating Point Arithmetics"
    ]
  },
  {
    "objectID": "posts/Python/floating_point.html#not-every-number-is-representable",
    "href": "posts/Python/floating_point.html#not-every-number-is-representable",
    "title": "Floating Point Arithmetics",
    "section": "Not every number is representable",
    "text": "Not every number is representable\nSince the significand has a finite number of bits available, some numbers are simply not representable. Famously, the number \\(0.1\\) is not perfectly representable, because in base 2 one would need infinite digits of the significand to represent it perfectly. It is similar to the number \\(\\frac{1}{3}\\) not being perfectly representable in base 10 with finite number of significant digits. For example, with 5 significant (decimal) digits, the best you could do is to represent \\(\\frac{1}{3}\\) by \\(0.33333\\).",
    "crumbs": [
      "Home",
      "Python",
      "Floating Point Arithmetics"
    ]
  },
  {
    "objectID": "posts/Python/floating_point.html#rounding",
    "href": "posts/Python/floating_point.html#rounding",
    "title": "Floating Point Arithmetics",
    "section": "Rounding",
    "text": "Rounding\nWhen this happens (the number entered is not perfectly representable), the floating point standard performs rounding. It represents the entered number as a close representable number. The direction of rounding can be either toward zero, to the nearest representable number, toward positive infinity or toward negative infinity. So, the code 0.1 + 0.1 + 0.1 == 0.3 evaluates to False, because the addition on the left-hand side is rounded to a different number than what the number 0.3 is represented with.\n\nprint(f\"{0.1+0.1+0.1:.60f}\")\n\nprint(f\"{0.3:.60f}\")\n\n0.300000000000000044408920985006261616945266723632812500000000\n0.299999999999999988897769753748434595763683319091796875000000",
    "crumbs": [
      "Home",
      "Python",
      "Floating Point Arithmetics"
    ]
  },
  {
    "objectID": "posts/Python/floating_point.html#sys.float_info",
    "href": "posts/Python/floating_point.html#sys.float_info",
    "title": "Floating Point Arithmetics",
    "section": "sys.float_info",
    "text": "sys.float_info\nIn Python, the parameters of floating point arithmetics on a particular machine can be found using the attribute float_info of the module sys. See the docs. For example, we can see that the rounding mode on my computer is “toward nearest”.\n\nimport sys\n\nprint(sys.float_info)\n\nsys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)\n\n\nNotice the value dig, “the maximum number of decimal digits that can be faithfully represented in a float”. To me, it is surprisingly small. On my computer, any number that has 15 or less significant digits, can be converted from str to float and back without change of value. But numbers with more than 15 significant digits aren’t guarranteed to have this property:\n\ns = \"3.14159265358979\"\nprint(s)\nprint(f\"{float(s):.60}\")\nprint(str(float(s)))\nprint(\"----------\")\ns = \"0.000000314159265358979\"\nprint(s)\nprint(f\"{float(s):.60}\")\nprint(str(float(s)))\n\n3.14159265358979\n3.141592653589790007373494518105871975421905517578125\n3.14159265358979\n----------\n0.000000314159265358979\n3.14159265358979004489366594968235979479231900768354535102844e-07\n3.14159265358979e-07\n\n\n\ns = \"9.876543210123459\"\nprint(s)\nprint(f\"{float(s):.60}\")\nprint(str(float(s)))\n\n9.876543210123459\n9.8765432101234598150085730594582855701446533203125\n9.87654321012346",
    "crumbs": [
      "Home",
      "Python",
      "Floating Point Arithmetics"
    ]
  },
  {
    "objectID": "posts/Python/floating_point.html#accumulation-of-rounding-error",
    "href": "posts/Python/floating_point.html#accumulation-of-rounding-error",
    "title": "Floating Point Arithmetics",
    "section": "Accumulation of rounding error",
    "text": "Accumulation of rounding error\nLet’s look at this code:\n\nx = 0\nfor _ in range(10):\n    x += 0.1\n    print(f\"{x:.55f}\")\n\n0.1000000000000000055511151231257827021181583404541015625\n0.2000000000000000111022302462515654042363166809082031250\n0.3000000000000000444089209850062616169452667236328125000\n0.4000000000000000222044604925031308084726333618164062500\n0.5000000000000000000000000000000000000000000000000000000\n0.5999999999999999777955395074968691915273666381835937500\n0.6999999999999999555910790149937383830547332763671875000\n0.7999999999999999333866185224906075745820999145507812500\n0.8999999999999999111821580299874767661094665527343750000\n0.9999999999999998889776975374843459576368331909179687500\n\n\nThe rounding errors are sometimes positive, sometimes negative. All in all, I think they are basicaly random. But they can accumulate over a large amount of operations. This code should test this.\nTo explain this code: It is obviously impossible to measure the rounding error of numbers that aren’t perfectly representable, like 0.1. Because I can’t represent the actual value to compare the tested number with. But each 10th iteration, the variables w, x, y and z should be integers. Due to the rounding error they are of course not, but I can create these target integers to compare w, x, y and z against to measure their rounding error.\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\n\nnum_iters = 1_000_000\nw, x, y, z = 0, 0, 0, 0\nerrors_1, errors_3, errors_7, errors_9 = [], [], [], []\nfor i in range(1, num_iters + 1):\n    w += 0.1\n    x += 0.3\n    y += 0.7\n    z += 0.9\n    if i != 1 and i % 10 == 0:\n        errors_1.append(w - round(i * 0.1))\n        errors_3.append(x - round(i * 0.3))\n        errors_7.append(y - round(i * 0.7))\n        errors_9.append(z - round(i * 0.9))\n\n\nplt.plot(errors_1)\nplt.plot(errors_3)\nplt.plot(errors_7)\nplt.plot(errors_9)\n\n\n\n\n\n\n\n\n\nplt.plot(np.log10(np.abs(np.array(errors_1))))\nplt.plot(np.log10(np.abs(np.array(errors_3))))\nplt.plot(np.log10(np.abs(np.array(errors_7))))\nplt.plot(np.log10(np.abs(np.array(errors_9))))\n\nC:\\Users\\marti\\AppData\\Local\\Temp\\ipykernel_15480\\2778079877.py:1: RuntimeWarning: divide by zero encountered in log10\n  plt.plot(np.log10(np.abs(np.array(errors_1))))\nC:\\Users\\marti\\AppData\\Local\\Temp\\ipykernel_15480\\2778079877.py:2: RuntimeWarning: divide by zero encountered in log10\n  plt.plot(np.log10(np.abs(np.array(errors_3))))\nC:\\Users\\marti\\AppData\\Local\\Temp\\ipykernel_15480\\2778079877.py:3: RuntimeWarning: divide by zero encountered in log10\n  plt.plot(np.log10(np.abs(np.array(errors_7))))\nC:\\Users\\marti\\AppData\\Local\\Temp\\ipykernel_15480\\2778079877.py:4: RuntimeWarning: divide by zero encountered in log10\n  plt.plot(np.log10(np.abs(np.array(errors_9))))\n\n\n\n\n\n\n\n\n\nWe can see the the magnitude of the error always fluctuates around zero, and sometimes is exactly zero (hence the errors RuntimeWarning: divide by zero encountered in log10 I guess), but the magnitude of this fluctuation generally increases with increasing number of floating point operations.\nHowever, the situation is a bit different when applied to subtracting. The errors are always in the same direction and their growth in magnitude is a bit questionable. So I’m actually confused.\n\nnum_iters = 1_000_000\nw_max, x_max, y_max, z_max = (\n    round(num_iters * 0.1),\n    round(num_iters * 0.3),\n    round(num_iters * 0.7),\n    round(num_iters * 0.9),\n)\nw, x, y, z = w_max, x_max, y_max, z_max\n\nerrors_1, errors_3, errors_7, errors_9 = [], [], [], []\nfor i in range(1, num_iters + 1):\n    w -= 0.1\n    x -= 0.3\n    y -= 0.7\n    z -= 0.9\n    if i != 1 and i % 10 == 0:\n        errors_1.append(w - (w_max - round(i * 0.1)))\n        errors_3.append(x - (x_max - round(i * 0.3)))\n        errors_7.append(y - (y_max - round(i * 0.7)))\n        errors_9.append(z - (z_max - round(i * 0.9)))\n\n\nplt.plot(errors_1)\nplt.plot(errors_3)\nplt.plot(errors_7)\nplt.plot(errors_9)\n\n\n\n\n\n\n\n\n\nplt.plot(np.log10(np.abs(np.array(errors_1))))\nplt.plot(np.log10(np.abs(np.array(errors_3))))\nplt.plot(np.log10(np.abs(np.array(errors_7))))\nplt.plot(np.log10(np.abs(np.array(errors_9))))",
    "crumbs": [
      "Home",
      "Python",
      "Floating Point Arithmetics"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "This is my personal datascience portfolio blog. I write this with these purposes in mind:\n\nTo show my potential employers some of my knowledge and skills (though this blog is incomplete for this purpose).\nFor me to have sort of a library of topics that I might want to get back to later. (It happenes to me from time to time that I need to use a concept that I know I learned and once understood, but it was a long time ago and I don’t ember all the details.)\nTo refresh my skills and knowledge and to kick start my datascience thinking again (see more in the upcoming article About me).\nTo fulfill my long-term dream of writing a datascience blog.\n\nI’m not fully documenting my whole datascience journey here. At least not now. I’m only including topics that I’m struggling with (and I learn them by writing about them) or I think are worth having here due to other reasons.\nAlso, I’m not focusing on the beauty of the blog. Creating websites is not something I’m good at or even interested in. That is why I want a simple blog that allows me to focus on the content."
  },
  {
    "objectID": "posts/Python/finger_exercises.html",
    "href": "posts/Python/finger_exercises.html",
    "title": "Textbook Finger Exercises",
    "section": "",
    "text": "The purpose of this notebook is to collect all the finger exercises I did from Introduction to Computation and Programming Using Python, third edition, With Application to Computational Modeling and Understanding Data by John V. Guttag.\n(Btw it is not complete, I didn’t do for example some very basic finger exercises toward the beginning of the book.)",
    "crumbs": [
      "Home",
      "Python",
      "Textbook Finger Exercises"
    ]
  },
  {
    "objectID": "posts/Python/finger_exercises.html#chapter-3-some-simple-numerical-programs",
    "href": "posts/Python/finger_exercises.html#chapter-3-some-simple-numerical-programs",
    "title": "Textbook Finger Exercises",
    "section": "Chapter 3: Some Simple Numerical Programs",
    "text": "Chapter 3: Some Simple Numerical Programs\n\n3.1 Exhaustive Enumeration\nWrite a program that asks the user to enter an integer and prints two integers, root and pwr, such that 1 &lt; pwr &lt; 6 and root**pwr is equal to the integer entered by the user. If no such pair of integers exists, it should print a message to that effect.\n\nx = int(input(\"Enter an integer: \"))\nanswer_root, answer_pwr = None, None\nif x == 0:\n    answer_root, answer_pwr = 0, 2\nelse:\n    if x &lt; 0:\n        for pwr in range(3, 6, 2):\n            for root in range(abs(x) + 1):\n                root *= -1\n                if root**pwr == x:\n                    answer_root, answer_pwr = root, pwr\n                    break\n    else:\n        for pwr in range(2, 6):\n            for root in range(abs(x) + 1):\n                if root**pwr == x:\n                    answer_root, answer_pwr = root, pwr\n                    break\nif answer_root is not None:\n    print(f\"For {x}, root is {answer_root} and power is {answer_pwr}\")\nelse:\n    print(\"No such pair exists.\")\n\nFor -8, root is -2 and power is 3\n\n\nWrite a program that prints the sum of the prime numbers greater than 2 and less than 1000. Hint: you probably want to have a loop that is a primality test nested inside a loop that iterates over the odd integers between 3 and 999.\n\nx = 0\nfor i in range(3, 1000, 2):\n    is_prime = True\n    for j in range(2, i):\n        if i % j == 0:\n            is_prime = False\n            break\n    if is_prime:\n        x += i\nprint(x)\n\n76125\n\n\n\n\n3.2 Approximate Solutions and Bisection Search\nWhat would have to be changed to make the code in Figure 3-5 work for finding an approximation to the cube root of both negative and positive numbers? Hint: think about changing low to ensure that the answer lies within the region being searched.\n\nx = float(input(\"Enter a number: \"))\nepsilon = 0.01\nlow = min(x, -1)\nhigh = max(1, x)\nans = (high + low) / 2\nnum_guesses = 1\nprint(f\"{low = }, {high = }, {ans = }\")\nwhile abs(ans**3 - x) &gt;= epsilon:\n    num_guesses += 1\n    if ans**3 &lt; x:\n        low = ans\n    else:\n        high = ans\n    ans = (high + low) / 2\n    print(f\"{low = }, {high = }, {ans = }\")\nprint(f\"{num_guesses = }\")\nprint(ans, \"is close to cube root of\", x)\n\nlow = -27.0, high = 1, ans = -13.0\nlow = -13.0, high = 1, ans = -6.0\nlow = -6.0, high = 1, ans = -2.5\nlow = -6.0, high = -2.5, ans = -4.25\nlow = -4.25, high = -2.5, ans = -3.375\nlow = -3.375, high = -2.5, ans = -2.9375\nlow = -3.375, high = -2.9375, ans = -3.15625\nlow = -3.15625, high = -2.9375, ans = -3.046875\nlow = -3.046875, high = -2.9375, ans = -2.9921875\nlow = -3.046875, high = -2.9921875, ans = -3.01953125\nlow = -3.01953125, high = -2.9921875, ans = -3.005859375\nlow = -3.005859375, high = -2.9921875, ans = -2.9990234375\nlow = -3.005859375, high = -2.9990234375, ans = -3.00244140625\nlow = -3.00244140625, high = -2.9990234375, ans = -3.000732421875\nlow = -3.000732421875, high = -2.9990234375, ans = -2.9998779296875\nnum_guesses = 15\n-2.9998779296875 is close to cube root of -27.0\n\n\nFigure 3-6 Using bisection search to estimate log base 2. (This is not a finger exercise, but I thought Figure 3-6 was wrong in that it doesn’t work for 0 &lt; x &lt; 1 and it is inefficient for huge x, so I wanted to improve on it. - I was right about 0 &lt; x &lt; 1, but it turned out for huge x it was actually efficient. It is because 2**ans very quickly reaches overflow error, so we should be very careful about low and high to ensure they are as tight as possible to prevent the overflow error.)\n\ny = float(input(\"Enter a positive number: \"))\nepsilon = 0.01\nlower_bound = 0\nif y &lt; 1:\n    x = 1 / y\nelse:\n    x = y\nwhile 2**lower_bound &lt; x:\n    lower_bound += 1\nlow = lower_bound - 1\nhigh = lower_bound + 1\nans = (high + low) / 2\nprint(f\"{low = }, {high = }, {ans = }\")\nwhile abs(2**ans - x) &gt;= epsilon:\n    if 2**ans &lt; x:\n        low = ans\n    else:\n        high = ans\n    ans = (high + low) / 2\n    print(f\"{low = }, {high = }, {ans = }\")\nif y &lt; 1:\n    print(-ans, \"is close to the log base 2 of\", y)\nelse:\n    print(ans, \"is close to the log base 2 of\", y)\n\nlow = 2, high = 4, ans = 3.0\n-3.0 is close to the log base 2 of 0.125\n\n\n\n\n3.4 Newton-Raphson\nAdd some code to the implementation of Newton-Raphson (in Figure 3-7) that keeps track of the number of iterations used to find the root. Use that code as part of a program that compares the efficiency of Newton-Raphson and bisection search. (You should discover that Newton-Raphson is far more efficient). Note: I also changed the code to find the cube root.\n\nk = float(input(\"Enter a number: \"))\nepsilon = 0.01\nguess = k / 2\nnum_guesses = 1\nwhile abs(guess**3 - k) &gt;= epsilon:\n    num_guesses += 1\n    guess -= (guess**3 - k) / (3 * guess**2)\nprint(f\"{num_guesses = }\")\nprint(\"Cube root of\", k, \"is about\", guess)\n\nnum_guesses = 8\nCube root of -27.0 is about -3.000000081210202",
    "crumbs": [
      "Home",
      "Python",
      "Textbook Finger Exercises"
    ]
  },
  {
    "objectID": "posts/Python/finger_exercises.html#chapter-4-functions-scoping-and-abstraction",
    "href": "posts/Python/finger_exercises.html#chapter-4-functions-scoping-and-abstraction",
    "title": "Textbook Finger Exercises",
    "section": "Chapter 4: Functions, Scoping, and Abstraction",
    "text": "Chapter 4: Functions, Scoping, and Abstraction\nUse find to implement a function satisfying the specifiaction\n\ndef find_last(s, sub):\n    \"\"\"s and sub are non-empty strings\n    Returns the index of the last occurence of sub in s.\n    Returns None if sub does not occur in s\"\"\"\n    if s.find(sub) == -1:\n        return None\n    else:\n        return len(s) - len(sub) - s[::-1].find(sub[::-1])",
    "crumbs": [
      "Home",
      "Python",
      "Textbook Finger Exercises"
    ]
  },
  {
    "objectID": "posts/Python/finger_exercises.html#chapter-5-structured-types-and-mutability",
    "href": "posts/Python/finger_exercises.html#chapter-5-structured-types-and-mutability",
    "title": "Textbook Finger Exercises",
    "section": "Chapter 5: Structured Types and Mutability",
    "text": "Chapter 5: Structured Types and Mutability\nUsing encoder and encrypt as models, implement the functions decoder and decrypt. Use them to decrypt the message\n\nbook = \"In a village of La Mancha, the name of which I have no desire to call to mind, there lived not long since one of those gentlemen that keep a lance in the lance-rack, an old buckler, a lean hack, and a greyhound for coursing.\"\ncipher_text = \"22*13*33*137*59*11*23*11*1*57*6*13*1*2*6*57*2*6*1*22*13*33*137*59*11*23*11*1*57*6*173*7*11\"\n\n\ngen_decode_keys = lambda book, cipher_text: {\n    s: book[int(s)] for s in set(cipher_text.split(\"*\"))\n}\n\n\ndecoder = lambda decode_keys, cipher_text: \"\".join(\n    [decode_keys[s] for s in cipher_text.split(\"*\")]\n)\n\n\ndecrypt = lambda book, cipher_text: decoder(\n    gen_decode_keys(book, cipher_text), cipher_text\n)\n\n\ndecrypt(book, cipher_text)\n\n'comprehension is incomprehensible'\n\n\nNote: We could decipher the text without creating the decrypt function using the call decoder(gen_decode_keys(book, cipher_text), cipher_text). I mean, we have eveything we need to decrypt the message before we implement the decrypt function. I guess the function decrypt is created for convenience, so that to decipher a message, we have a function with a straightforward usage: One parameter is the book and one parameter is the cipher text and we don’t have to care about anything else. I think that is to honor the abstraction. We shouldn’t care about how the function works (i.e. that it uses decoder and gen_decode_keys functions) as long as it simply takes the book, the cipher text and produces the decoded the message.",
    "crumbs": [
      "Home",
      "Python",
      "Textbook Finger Exercises"
    ]
  },
  {
    "objectID": "posts/Python/global_variables.html",
    "href": "posts/Python/global_variables.html",
    "title": "Scopes and Global Variables",
    "section": "",
    "text": "In this article we will discuss two python keywords - global and nonlocal - and scoping. Surprisingly, this topic was very hard to research and to wrap my head around. So, this post is, as always, a mix of how I understand the topic and what I was able to find online and verify (no ChatGPT-only answers). The focus here was to cover the most important and veryfiable scenarios and behaviors of the language.\nNote: Cells in this notebook must be evaluated individually, meaning the kernel must be restarted before each cell is run. Otherwise name collisions may occur. In particular, some demonstrations depend on a global variable not being defined, but it may have been defined in a previous cell, ruining the demonstration. So, restart kernel before running each cell in this notebook.",
    "crumbs": [
      "Home",
      "Python",
      "Scopes and Global Variables"
    ]
  },
  {
    "objectID": "posts/Python/global_variables.html#terminology",
    "href": "posts/Python/global_variables.html#terminology",
    "title": "Scopes and Global Variables",
    "section": "Terminology",
    "text": "Terminology\nA scope is a block of code in which variables can be visible. A namespace is a table that defines variables (a mapping from names to pointers). Each scope has its own namespace.\nA global scope is the one at the level of a module. This is also the level that your IPython shell is in when you start a new one. Any variable you define at this level is a global variable.\nInside this scope you can create an inner scope, for example by defining a function. And now things start to be interesting. Let’s assume we are in the scope of this function. Now, the current scope is called a local scope and the outer scope (which also happens to be the global scope in this case) is called a nonlocal scope.\nThis terminology holds for any number of nested scopes: The current scope is always local, the closest higher scope is nonlocal and the top-most scope is global.",
    "crumbs": [
      "Home",
      "Python",
      "Scopes and Global Variables"
    ]
  },
  {
    "objectID": "posts/Python/global_variables.html#types-of-scopes-and-legb",
    "href": "posts/Python/global_variables.html#types-of-scopes-and-legb",
    "title": "Scopes and Global Variables",
    "section": "Types of Scopes and LEGB",
    "text": "Types of Scopes and LEGB\nThere is one more scope above global - the built-in scope. The full list of scopes in Python is this:\n\nbuilt-in\nglobal\nnonlocal (recursive)\nlocal\n\nThis means that when a variable is referenced in a local scope, Python first looks for it in the local scope. If it isn’t found there the nearest enclosing scope is searched (the nonlocal scope). If it is not found there then the next higher scope is searched and so on, until a global scope is reached. If a variable is not found in the global scope, the built-in scope is searched. If the variable is not even here, a NameError is raised. This lookup process is called the LEGB rule - from Local, Enclosing, Global, Built-in.",
    "crumbs": [
      "Home",
      "Python",
      "Scopes and Global Variables"
    ]
  },
  {
    "objectID": "posts/Python/global_variables.html#nesting-of-scopes",
    "href": "posts/Python/global_variables.html#nesting-of-scopes",
    "title": "Scopes and Global Variables",
    "section": "Nesting of Scopes",
    "text": "Nesting of Scopes\nIt is important to remind here that nested scopes are created by defining new functions (or generators etc., see below), NOT by calling them. For example, these are not nested scopes - the function innerfn isn’t actually “inner” and the function outerfn isn’t actually “outer”. They are same-level functions, just called from one another. They do not create nested scopes.\n\ndef innerfn():\n    print(x)\n\ndef outerfn():\n    x = 2\n    innerfn()\n\nx = 1\nouterfn()\n\n1\n\n\nWe can see it because when innerfn is called from within outerfn, the number 1 is printed, and not 2. This is what happened:\n\nWhen innerfn is called from within outerfn, the variable x is first searched for locally.\nIt is not found there, so Python completely skips the calling scope and searches for x in the scope where innerfn was defined - the global scope in this case.\nx is found there so its value is used (1). The value 2 is not used, because Python never searches for x in the scope from which innerfn is called.\nIf x wasn’t found in the global scope (where innerfn is defined), Python would look in the built-in scope.\n\nBy the way, any variable defined anywhere in a function scope is always only searched for locally. Which means this code throws an error (UnboundLocalError):\n\nx = 1\ndef fn():\n    print(x)  # UnboundLocalError: cannot access local variable 'x' where it is not associated with a value\n    x = 2\nfn()\n\nAt the first line of the function, we need to get the variable x. It is not yet defined locally, so it doesn’t exist in the local namespace, but it is defined in the enclosing (nonlocal) scope so we should be able to use that value, right? Wrong. Python knows in advance that somewhere down the body of the function the variable x is defined. So it treats it as a local to the function and only looks for it in the local namespace. But it is not found there at the point of the print statement, so an error is thrown.",
    "crumbs": [
      "Home",
      "Python",
      "Scopes and Global Variables"
    ]
  },
  {
    "objectID": "posts/Python/global_variables.html#what-creates-a-scope",
    "href": "posts/Python/global_variables.html#what-creates-a-scope",
    "title": "Scopes and Global Variables",
    "section": "What Creates a Scope",
    "text": "What Creates a Scope\nNew scopes are created by modules, functions, methods, lambda expressions, comprehensions and generator expressions. Surprisingly, classes and their instances do not create new standard LEGB scopes, their behavior is more complicated. We will talk about that at the end of this post.\nOn the other hand, constructs such as if, for, while, with and try - except (with a small exception) don’t create their own scopes.\nLet’s discuss each case:\n\nModules\nEach module has its own (global) scope. If you call one module from another, the called module does NOT see variables in the calling module.\nLet’s look at an example. The module a.py defines a function f which prints the variable x. But the variable x isn’t defined anywhere in the module a.py.\n\n# Creating a new module a.py in the current working directory and populating it with code\nimport os\n\ncode = \"\"\"\ndef f():\n    print(x)\n\"\"\"\n\nwith open(\"a.py\", \"w\") as f:\n    f.write(code)\n\nHere the module a.py defines a function f that prints the variable x. But the variable x isn’t defined anywhere in the module a.py. When the function is called (doesn’t matter from where), Python first looks for x locally in f, then in the global scope of a.py and finally in the built-in scope. It is not found so a NameError is thrown. The global scope of the calling module is never searched.\n\nimport a\n\nx = 1\na.f()  # NameError: name 'x' is not defined\n\nBut there is a way to make the function work. We can create the variable x in the module a.py from the calling module. The body of a function is, as usual, only evaluated when the function is called. And when the function a.f is called, the module a already has an attribute (or variable) x defined.\n\nimport a\n\na.x = 1\na.f()\n\n1\n\n\n\nimport os\nos.remove('a.py')\n\n\n\nFunctions\nFunctions are the most important constructs that create new scopes. This includes all possible versions of functions:\n\nusual functions (keyword def)\nclass functions (usual functions defined in a class body)\ninstance methods (they are just class functions to which instances are automatically passed in as the first argument)\nlambda expressions (which are just annonymous functions)\n\n\n\nComprehensions and generator expressions\nThey also create new scopes, just as functions do. Variables defined in them are only visible from inside of the comprehension/generator expression.\n\nL = [i**2 for i in range(3)]\nprint(i)  # NameError: name 'i' is not defined\n\n\ngen = (x**2 for x in range(3))\nprint(x)  # NameError: name 'x' is not defined\nfor i in gen:\n    print(i)\nprint(x)  # NameError: name 'x' is not defined\n\nOne may think that scopes of comprehensions and generator expressions are not very interesting, since they immediatelly dissappear once the expressions are finished. But that is not true, they don’t disappear. The point of evaluation just moves back to the scope where they are created. But the inner scope still exists. We can still index into e.g. the list comprehension and access its scope. Yes, this is mostly unimportant, but it becomes important when the list elements are functions:\n\nL = [(lambda: i) for i in range(3)]\nprint(L[0](), L[1](), L[2]())\n\n2 2 2\n\n\nHere, the list comprehension defines an iterative variable i that goes from 0 to 2, and for each value of i it creates an element of the list that is the function lambda: i. Meaning it is a function that returns the value of a variable i. But that variable is not the function’s parameter nor is it defined anywhere in the function.\nSo the functions are defined, the list is created, but the functions are not evaluated untill called (that is the usual behavior of any Python function). Then, when the list is accessed and the functions are called, their bodies are evaluated. For each function, the variable i needs to be found. Python first looks into the function locally, but doesn’t find the variable i. So Python then searches the enclosing scope, which is the list comprehension’s scope. And in that scope, the variable i exists and is now bound to the value 2. So that value is returned from each function in the list.\nTo make the individual functions behave in the way that each returns a different value of i (the behavior one may have wanted in the first place), we need each function to accept one variable and define its default value. Python evaluates default values at function definition time - NOT when the function is called (only the body is evaluated when function is called). So, this code returns three different values:\n\nL = [(lambda x=i: x) for i in range(3)]\nprint(L[0](), L[1](), L[2]())\n\n0 1 2\n\n\n\n\nSpecial case: except as\nLet’s look at this code:\n\ntry:\n    1/0\nexcept ZeroDivisionError as e:\n    print(e)\nprint(e)  # NameErrorNameError: name 'e' is not defined\n\nIn this case, the except block still doesn’t define a new scope nor a new namespace, but it does define a new temporary binding for the name defined after as. This variable is then NOT visible outside the except block.\nIn the case of with however, e.g. as in with open('hello') as f, the name f is visible outside the with block.\n\nwith open('hello', 'w') as f:\n    pass\nprint(f)\n\n&lt;_io.TextIOWrapper name='hello' mode='w' encoding='cp1252'&gt;",
    "crumbs": [
      "Home",
      "Python",
      "Scopes and Global Variables"
    ]
  },
  {
    "objectID": "posts/Python/global_variables.html#keywords-global-and-nonlocal",
    "href": "posts/Python/global_variables.html#keywords-global-and-nonlocal",
    "title": "Scopes and Global Variables",
    "section": "Keywords global and nonlocal",
    "text": "Keywords global and nonlocal\nSo far we have seen that a variable is iteratively searched for from the local scope to the built-in scope until it is found and the corresponding value is used. By the way, it means that variables defined in higher-level scopes are read-only in lower-level scopes. I mean, we can use higher-level variables in lower-level scopes, but we cannot change them. Any attempt to change a variable defined in a higher-level scope would mean we change the variable only in the local scope:\n\nx = 1\ndef fn():\n    print(x)  # We can read variables defined in higher-level scopes\nfn()\n\n1\n\n\n\nx = 1\ndef fn():\n    x = 2\nprint(x)  # But we cannot change their values, as any such change would be local only and would not propagate to the higher level.\n\n1\n\n\nThe keywords global and nonlocal enable us to both change higher-level variables and to manipulate the variable lookup process. For example, the keyword global says that:\n\nThe variable(s) following it are to be immediatelly searched for in the global namespace (skipping the local and all non-local namespaces)\nIt is possible to change these variables in the global namespace.\n\nIt is basically a direct connection to the global namespace (for that particular variable).\nThe keyword nonlocal does the exact same thing with the difference that it connects to the non-local scope.\nWe can demonstrate this behavior like this. First, we define three nested functions and define a variable x in each of them but with a different value:\n\nx = 0\ndef fn1():\n    x = 1\n    def fn2():\n        x = 2\n        def fn3():\n            x = 3\n            print(f'inside fn3: {x = }')\n        fn3()\n        print(f'inside fn2: {x = }')\n    fn2()\n    print(f'inside fn1: {x = }')\nfn1()\nprint(f'inside global scope: {x = }')\n\ninside fn3: x = 3\ninside fn2: x = 2\ninside fn1: x = 1\ninside global scope: x = 0\n\n\nThen we introduce a single change: In the bottom-most scope, instead of defining x, we declare that we want to use the one defined in the global scope. We can see that indeed the value of x in the global scope is then used here in the bottom-most scope. Other scopes remained untouched.\n\nx = 0\ndef fn1():\n    x = 1\n    def fn2():\n        x = 2\n        def fn3():\n            global x\n            print(f'inside fn3: {x = }')\n        fn3()\n        print(f'inside fn2: {x = }')\n    fn2()\n    print(f'inside fn1: {x = }')\nfn1()\nprint(f'inside global scope: {x = }')\n\ninside fn3: x = 0\ninside fn2: x = 2\ninside fn1: x = 1\ninside global scope: x = 0\n\n\nWe can even change the global variable from the inner scope:\n\nx = 0\nprint(f'at the start of global scope: {x = }')\ndef fn1():\n    x = 1\n    def fn2():\n        x = 2\n        def fn3():\n            global x\n            x = 3\n            print(f'inside fn3: {x = }')\n        fn3()\n        print(f'inside fn2: {x = }')\n    fn2()\n    print(f'inside fn1: {x = }')\nfn1()\nprint(f'at the end of global scope: {x = }')\n\nat the start of global scope: x = 0\ninside fn3: x = 3\ninside fn2: x = 2\ninside fn1: x = 1\nat the end of global scope: x = 3\n\n\nThen we see the same behavior is achieved by the keyword nonlocal, except the affected scope is the nonlocal scope.\n\nx = 0\ndef fn1():\n    x = 1\n    def fn2():\n        x = 2\n        print(f'at the start of fn2: {x = }')\n        def fn3():\n            nonlocal x\n            x = 3\n            print(f'inside fn3: {x = }')\n        fn3()\n        print(f'at the end of fn2: {x = }')\n    fn2()\n    print(f'inside fn1: {x = }')\nfn1()\nprint(f'inside global scope: {x = }')\n\nat the start of fn2: x = 2\ninside fn3: x = 3\nat the end of fn2: x = 3\ninside fn1: x = 1\ninside global scope: x = 0\n\n\nIf we use nonlocal x and the variable x isn’t found in the nonlocal namespace, the search continues to higher enclosing scopes:\n\nx = 0\ndef fn1():\n    x = 1\n    def fn2():\n        def fn3():\n            nonlocal x\n            print(f'inside fn3: {x = }')\n        fn3()\n        print(f'inside fn2: {x = }')\n    fn2()\n    print(f'inside fn1: {x = }')\nfn1()\nprint(f'inside global scope: {x = }')\n\ninside fn3: x = 1\ninside fn2: x = 1\ninside fn1: x = 1\ninside global scope: x = 0\n\n\nBut the search stops just before the global scope. If we declare a variable to be nonlocal, it cannot be global:\n\nx = 0\ndef fn1():\n    def fn2():\n        def fn3():\n            nonlocal x  # SyntaxError: no binding for nonlocal 'x' found\n            print(f'inside fn3: {x = }')\n        fn3()\n        print(f'inside fn2: {x = }')\n    fn2()\n    print(f'inside fn1: {x = }')\nfn1()\nprint(f'inside global scope: {x = }')\n\nThis differs from the global keyword, because when a varaible is declared global but not found in the global namespace, the next scope - built-in - is searched.\n\ndef fn1():\n    def fn2():\n        def fn3():\n            global sum\n            print(f'inside fn3: {sum = }')\n        fn3()\n        print(f'inside fn2: {sum = }')\n    fn2()\n    print(f'inside fn1: {sum = }')\nfn1()\nprint(f'inside global scope: {sum = }')\n\ninside fn3: sum = &lt;built-in function sum&gt;\ninside fn2: sum = &lt;built-in function sum&gt;\ninside fn1: sum = &lt;built-in function sum&gt;\ninside global scope: sum = &lt;built-in function sum&gt;\n\n\n\ndef fn1():\n    def fn2():\n        def fn3():\n            nonlocal sum  # SyntaxError: no binding for nonlocal 'sum' found\n            print(f'inside fn3: {sum = }')\n        fn3()\n        print(f'inside fn2: {sum = }')\n    fn2()\n    print(f'inside fn1: {sum = }')\nfn1()\nprint(f'inside global scope: {sum = }')",
    "crumbs": [
      "Home",
      "Python",
      "Scopes and Global Variables"
    ]
  },
  {
    "objectID": "posts/Python/global_variables.html#functions-globals-and-locals",
    "href": "posts/Python/global_variables.html#functions-globals-and-locals",
    "title": "Scopes and Global Variables",
    "section": "Functions globals and locals",
    "text": "Functions globals and locals\nThere is another way to access the global namespace from within a lower-level scope: The built-in function globals. Its documentation speaks for itself.\n\nhelp('globals')\n\nHelp on built-in function globals in module builtins:\n\nglobals()\n    Return the dictionary containing the current scope's global variables.\n\n    NOTE: Updates to this dictionary *will* affect name lookups in the current\n    global scope and vice-versa.\n\n\n\nIts sibling, locals, is similar but we don’t have the guarantee that we can use it to change local variables. But why would we want that? We can simply change local variables in the usual way. I mean, we don’t have to do locals()['x'] = 1, we can simply write x = 1. (We don’t have this direct option for the global variables, which is why we need the global keyword.)\n\nhelp('locals')\n\nHelp on built-in function locals in module builtins:\n\nlocals()\n    Return a dictionary containing the current scope's local variables.\n\n    NOTE: Whether or not updates to this dictionary will affect name lookups in\n    the local scope and vice-versa is *implementation dependent* and not\n    covered by any backwards compatibility guarantees.",
    "crumbs": [
      "Home",
      "Python",
      "Scopes and Global Variables"
    ]
  },
  {
    "objectID": "posts/Python/global_variables.html#classes-and-scoping",
    "href": "posts/Python/global_variables.html#classes-and-scoping",
    "title": "Scopes and Global Variables",
    "section": "Classes and Scoping",
    "text": "Classes and Scoping\nThis is the most difficult part of the topic. Classes differ substantially from functions in terms of scoping.\nThe first thing to know is that code in class bodies, unlike code in functions bodies, is evaluated immediately at the class definition time. I mean, code inside a function isn’t run until the function is called. But code inside a class body is evaluated immediately as the class is being defined\nSecond and probably the most important thing is that scopes of class bodies do not extend to class functions, not even to comprehensions and generator expressions used in class bodies. As a result, class bodies are NOT enclosing scopes for class functions. Also, scopes of class bodies disappear after the class is defined. Names defined in a class body are moved to the attribute dictionary of the class (__dict__) after the class is finished defining, but the scope itself disappears. As a result, the scope enclosing class functions is the scope in which the class is defined.\nThird, class instances do not create new scopes either. They just create namespaces. But these namespaces do not participate in the LEGB name resolution rules. Thus, the scope enclosing instance methods is still the scope in which the class is defined.\nMost of the class scoping behavior is determined by these facts.\nAnd just for completeness: Instance attribute lookup is a completely different process than name resolutions in functions and methods. Attribute access follows completely different rules than LEGB. For instance attribute lookups, first the instance namespace is searched. Then the class namespace is searched. Then there is MRO, descriptor handling, __getattribute__ fallback etc. But that is a topic for a future post.\nLet’s look at some examples of scoping in classes.\n\nExample 1\nClass body executes immediately, top to bottom. Unlike functions, which execute only after they are called.\n\nprint(\"before class\")\n\nclass C:\n    print(\"inside class body\")\n    def f(self):\n        print('inside class function f')\n\nprint(\"after class\")\nC().f()\n\nbefore class\ninside class body\nafter class\ninside class function f\n\n\n\nprint(\"before function\")\n\ndef f():\n    print(\"inside function\")\n\nprint(\"after function\")\nf()\n\nbefore function\nafter function\ninside function\n\n\nAs a direct implication of this, we cannot reference variables defined after the class definition. Functions on the other hand can do exactly that.\n\ndef f():\n    return x\n\nx = 1\nprint(f())\n\n1\n\n\n\nclass C:\n    y = x  # NameError: name 'x' is not defined\n    pass\n\nx = 1\n\n\n\nExample 2\nA class body is not an enclosing LEGB scope for class functions. When a class function is called, and that function uses a variable, Python searches for that variable like this: First locally in the function, of course, and then it goes look inside the scope in which the class was defined. It completely skips the body of the class, because it is not the enclosing scope. (It also skips the scope from which the function is called, but we have seen this exact behavior for functions, this is just a reminder.)\n\nx = 1\n\nclass C:\n    x = 2\n    def f():\n        return x\n\ndef fn():\n    x = 3\n    print(C.f())\n    print(C.x)\n    print(x)\n\nfn()\n\n1\n2\n3\n\n\nA class body is not even the enclosing scope for list comprehensions or generator expressions inside that class body. But in a weird way I don’t fully understand:\n\n# This works\nclass C:\n    L = [1, 2, 3]\n    new = [i for i in L]\nC().new\n\n[1, 2, 3]\n\n\n\n# This doesn't work\nclass C:\n    x = 2\n    new = [i + x for i in range(3)]  # NameError: name 'x' is not defined\nC().new\n\n\n# In functions however, it works:\ndef fn():\n    x = 2\n    return [i + x for i in range(3)]\n\nfn()\n\n[2, 3, 4]\n\n\n\n\nExample 3\nFor instance methods, the situation is the very same as for class functions: The enclosing scope for instance methods is still the scope in which the class is defined. Instances do not create new scopes. They create namespaces (different from class namespaces), but these are not scopes. They are not searched when a name is referenced in a method. And the class body is not searched either. So again, if a name is referenced in a method, first the local scope of the method is searched, then the scope in which the class is defined.\nFor instance attribute lookups, first the instance namespace is searched, then the class namespace.\n\nx = 1\n\nclass C:\n    x = 2\n    def f(self):\n        return x\n\nc = C()\nprint('c.x   is', c.x)  # instance c doesn't define x, so the class's x is used here\nprint('c.f() is', c.f())\nc.x = 3  # now the instance c does define x, which is prioritized before the class's\nprint('c.x = 3')\nprint('c.x   is', c.x)\nprint('C.x   is', C.x)\nprint('c.f() is', c.f())\n\nc.x   is 2\nc.f() is 1\nc.x = 3\nc.x   is 3\nC.x   is 2\nc.f() is 1\n\n\n\n\nExample 4\nThough the scope of a class body disappears after the class is defined, until then it is still a normal scope. In particular, it does have access to all its enclosing scopes. It also creates a new namespace (that later becomes the class’s __dict__ attribute). But if we we want to reference variables defined in a class body from outside of the class body, we must access it via the class name. Btw “outside of the class body” includes class functions/instance methods, because as we have seen class body is not the enclosing scope for class functions/instance methods.\n\ny = 1\n\nclass C:\n    print(y)  # class body has access to the enclosing scope\n    z = 2\n\n    def f():\n        print(C.z)\n\nprint(C.z)\nC.f()\n\n1\n2\n2\n\n\nWe can even use nonlocal in the class body to reference a variable defined in the enclosing scope. (As we have seen if we use nonlocal, the variable cannot be global, so we need to nest the class inside a function).\n\ndef fn():\n    x = 2\n    class C:\n        nonlocal x\n        print(x)\n\nfn()\n\n2\n\n\nWhen nonlocal is used inside a class function/instance method, it again refers to outside of the class, not the class body.\n\ndef fn():\n    x = 2\n    class C:\n        x = 1\n        def g(self):\n            nonlocal x\n            print(x)\n\n    C().g()\n    print(C().x)\nfn()\n\n2\n1\n\n\n\n\nExample 5\nA nice summarizing example. Here we can see that:\n\nCode in class body is evaluated at class definition time.\nClass functions are defined at class definition time, but their code is not run until they are envoked.\nClass body is not the enclosing scope for class functions (instance methods)\nWe can reference class variables only via the class name.\n\n\nx = 2\nclass C:\n    print('inside class body')\n    x = 1\n    def f(self):\n        print('inside class function')\n        print(\"C.x is\", C.x)\n        print(\"x is\", x)\n\nprint('inside global scope')\nC().f()\n\ninside class body\ninside global scope\ninside class function\nC.x is 1\nx is 2",
    "crumbs": [
      "Home",
      "Python",
      "Scopes and Global Variables"
    ]
  }
]